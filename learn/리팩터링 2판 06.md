

## 리팩터링 6장



### 1. 함수 추출하기

함수를 추출할 때에는 함수가 너무 길어지거나 재사용적인 측면, 목적과 구현을 분리하는 측면에서 함수를 추출 할 수 있다.

함수의 길이는 중요하지 않다. 단 한 줄짜리 함수여도 추출할 만한 가치가 있다면 추출하는 것이 좋다.

- 코드 조각을 찾아 무슨 일을 하는지 파악
- 독립적인 함수로 추출
- 목적에 맞는 이름을 붙인다 (어떻게가 아닌 무엇을 하는지가 드러나게 이름을 붙인다)

### 2. 함수 인라인 하기

- 간접호출을 너무 과하게 쓰는 코드
- 함수가 너무 많아서 위임 관계가 복잡하게 얽혀 있으면 오히려 더 읽기가 어려움

- 인라인할 함수를 호출하는 곳을 찾는다
- 각 호출문을 함수 본문으로 교체
- 함수 정의를 삭제



### 3. 변수 추출하기

표현식이 너무 복잡해서 이해하기 어려울 때 지역 변수를 활용해서 명시적인 이름을 지정해주면 좀 더 이해하기 쉬운 코드가 된다.

- 추출하려는 표현식에 부작용은 없는 지 확인
- 불변 변수를 선언하고 표현식의 복제본을 대입
- 원본 표현식을 새로 만든 변수로 교체




### 4. 변수 인라인 하기

변수의 이름이 원래 표현식과 크게 다를 바가 없을 경우 변수가 주변코드를 리팩터링 하는데 방해가 될 경우에는 변수를 인라인 하는 것이 좋다

- 표현식에서 부작용이 생기지는 않는지 확인
- 변수가 불변으로 선언되지 않았다면 불변으로 만든 후 테스트
- 이 변수를 가장 처음 사용하는 코드를 찾아서 표현식으로 바꾼다.



### 5. 함수 선언 바꾸기

함수의 이름이 명확하다면 함수의 이름을 읽는 것 만으로 이 함수가 어떤 역할을 하는지 알 수 있다.

하지만 그렇지 않다면 코드를 읽는 것에 혼란이 온다.

- 매개변수를 제거하려거든 먼저 함수 본문에서 제거 대상 매개변수를 참조하는 곳이 없는지 확인
- 메서드 선언을 원하는 형태로 변경
- 기존 메서드 선언을 참조하는 부분을 모두 찾아서 바뀐 형태로 수정



### 6. 변수 캡슐화 하기

변수의 유효 범위가 넓어질수록 다루기가 어려워진다, 변경이 될 수 있기 때문에 그래서 데이터의 유효범위가 넓을 수록 함수를 통해서만 그 데이터에 접근 할 수 있도록 만드는 것이 좋고 데이터를 불변성을 지키며 사용하면 변경될 일이 없기 때문에 불변성을 지키면서 사용하는 것이 좋다

- 변수로의 접근과 갱신을 전담하는 캡슐화 함수를 만든다
- 변수를 직접 참조하던 부분을 모두 적절한 캡슐화 함수 호출로 바꾼다



### 7. 변수 이름 바꾸기

명확한 이름의 변수는 프로그래머가 하려는 일에 관해 많은 것을 설명해줄 수 있다.

- 폭넓게 쓰이는 변수라면 캡슐화를 고려
- 이름을 바꿀 변수를 참조하는 곳을 모두 찾아서 하나씩 변경한다



### 8. 매개변수 객체 만들기

데이터 항목 여러 개가 이 함수에서 저함수로 함께 자주 쓰일 경우 이 데이터를 하나의 구조로 모아준다.

이렇게 하면 데이터 사이의 관계가 명확해진다는 이점을 얻을 수 있고, 매개변수 수도 줄일 수 있으며 모든 함수가 원소를 참조할 때 항상 같은 이름을 사용하기 때문에 일관성도 높여준다.

- 적당한 데이터 구조가 아직 마련되어 있지 않다면 새로 만든다.
- 함수 선언 바꾸기로 새 데이터 구조를 매개변수로 추가한다.
- 함수 호출 시 새로운 데이터 구조 인스턴스를 넘기도록 수정한다
- 기존 매개변수를 사용하던 코드를 새 데이터 구조의 원소를 사용하도록 바꾼다.
- 기존 매개변수를 제거한다.



### 9. 여러 함수를 클래스로 묶기

클래스를 활용해 데이터와 함수를 하나의 공유환경으로 묶어 다른 프로그램 요소와 어우러질 수 있도록 그중 일부를 외부에 제공한다.

클래스로 묶으면 이 함수들이 공유하는 공통 환경을 더 명확하게 표현할 수 있고, 각 함수에 전달되는 인수를 줄여 객체안에서의 함수 호출을 간결하게 만들 수 있다.

- 함수들이 공유하는 공통 데이터 레코드를 캡슐화한다
- 공통 레코드를 사용하는 함수 각각을 새 클래스로 옮긴다
- 데이터를 조작하는 로직들은 함수로 추출해서 클래스로 옴긴다



### 10. 여러 함수를 변환 함수로 묶기

소프트웨어는 데이터를 입력받아 여러가지 정보를 도출한다. 도출된 정보는 여러 곳에 사용될 수 있는데 이런 도출 작업들을 한데로 모아두면 검색과 갱신을 일관된 장소에서 처리할 수 있고 로직 중복도 막을 수 있다.

- 변환할 레코드를 입력 받아서 값을 그대로 반환하는 반환 함수를 만든다.
- 묶을 함수 중 함수 하나를 골라서 본문 코드를 변환 함수로 옮기고, 처리 결과를 레코드에 새필드로 기록한다. 그런다음 클라이언트 코드가 이 필드를 사용하도록 수정한다.



### 11. 단계 쪼개기

서로 다른 두대상을 한꺼번에 다루는 코드는 좋지않다. 두개의 대상을 동시에 생각해야 하기 때문이다. 그래서 이러한 코드는 각각을 별개의 모듈로 나누는 것이 좋다 이렇게 하면 코드를 수정할 때 하나에만 집중할 수 있기 때문이다.

- 두 번째 단계에 해당하는 코드를 독립 함수로 추출
- 중간 데이터 구조를 만들어서 앞에서 추출한 함수의 인수로 추가
- 추출한 두 번째 단계의 함수의 매개변수를 하나씩 검토한다. 그중 첫 번째 단계에서 사용되는 것은 중간 데이터 구조로 옮긴다.
- 첫 번째 단계 코드를 함수로 추출하면서 중간 데이터 구조를 반환하도록 만든다.
