## 리팩터링 8장 기능이동



### 8.1 함수 옮기기

좋은 소프트웨어의 설계는 모듈화가 핵심이다.  어떤 함수가 자신이 속한 모듈 A의 요소들보다 다른 모듈 B의 요소들을 더 많이 참조한다면 모듈 B로 옮겨줘야 한다.

1. 선택한 함수가 현재 컨텍스트에서 사용 중인 모든 프로그램 요소를 살펴본다.

   - 얽혀 있는 함수가 여러개라면 작은 함수부터

2. 선택한 함수가 다형메서드인지 확인한다.

   - 객체 지향 언어에서는 같은 메서드가 슈퍼클래스나 서브클래스에 있는지도 확인해야한다.

3. 선택한 함수를 타깃 컨텍스트로 복사한다. ( 원래의 함수를 소스함수, 새로운 함수를 타깃함수)

4. 소스 컨텍스트에서 타깃 함수를 참조할 방법을 찾아 반영한다.

5. 소스 함수를 타깃 함수의 위임 함수가 되도록 수정한다.

6. 소스함수를 인라인할지 생각해본다.

   

### 8.2 필드 옮기기

함수에 데이터를 넘길 때마다 또다른 데이터의 필드도 함께 넘기고 있다면 데이터 위치를 옮겨야 한다. 상호 관계가 명확하게 드러나도록 데이터를 레코드에 담는게 좋다. 

1. 소스 필드가 캡슐화되어 있지 않다면 캡슐화한다
2. 타깃 객체의 필드를 생성한다.
3. 소스 객체해서 타깃 객체를 참조할 수 있는지 확인
4. 접근자들이 타깃 필드를 사용하도록 수정한다
   - 여러 소스에서 같은 타깃을 공유한다면 먼저 세터를 수정하여 타깃 필드와 소스 필드 모드를 갱신 하게한다.
   - 일관성을 깨뜨리는 갱신을 검출할 수 있도록 검증할 수 있는 어서션을 추가



### 8.3 문장을 함수로 옮기기

특정 함수를 호출하는 코드가 나올 때마다 그 앞이나 뒤에서 똑같은 코드가 추가로 항상 실행되야 한다면, 그부분을 호출 함수로 합치는 것이 좋다.

1. 반복 코드가 함수 호출 부분과 멀리 떨어져있다면 근처로 옮긴다.
2. 타깃 함수를 호출하는 곳이 한 곳 뿐이면 단순히 소스 위치에서 해당 코드를 잘라내어 호출함수로 옮긴다 <= 이경우 나머지 단계는 무시
3. 호출자가 둘 이상이면 호출자 중 하나에서 타깃 함수 호출 부분과 그 함수로 옮기려는 문장들을 함께 다른 함수로 추출 한다.
4. 다른 호출자 모두가 방금 추출한 함수를 사용하도록 수정한다
5. 모든 호출자가 새로운 함수를 사용하게 되면 원래 함수를 새로운 함수 안으로 인라인한 후에 원래함수를 제거한다.



### 8.4 문장 호출한 곳으로 옮기기

초기에는 응집도 높고 한 가지 일만 수행하던 함수가 둘 이상의 다른 일을 수행하게 바뀔 수 있다. 이럴때에는 여러 곳에서 사용하던 기능이 일부 호출자에게 다르게 동작하도록 바뀌어야 한다.



### 8.5 인라인 코드를 함수 호출로 바꾸기

함수의 이름이 코드의 동작 방식보다는 목적을 말해주기 때문에 함수를 활용하면 코드를 이해하기가 쉬워진다. 네이밍이 잘되었을 경우

그리고 중복을 없애는 데도 효과적이다.



### 8.6 문장 슬라이드하기

관련된 코드들이 가까이 모여 있다면 이해하기가 더쉽다. 

예를들어 변수를 선언할 때 그 변수가 사용되는 곳 바로 위에 선언되어 있으면 이해하기가 더쉽다, 관련있는 문장들은 서로 모아둔다.

1. 코드 조각을 이동할 목표 위치를 찾는다. 코드 조각의 원래 위치와 목표 위치 사이의 코드를 훑어보면서 조각을 모으고 나면 동작이 달라지는 코드가 있는지 살핀다. 다음과 같은 간섭이 있다면 이 리팩터링은 포기한다.
   - 코드 조각에서 참조하는 요소를 선언하는 문장 앞으로는 이동할 수 없다.
   - 코드 조각을 참조하는 요소의 뒤로는 이동할 수 없다.
   - 코드 조각에서 참조하는 요소를 수정하는 문장을 건더뛰어 이동할 수 없다.
   - 코드 조각이 수정하는 요소를 참조하는 요소를 건너뛰어 이동할 수 없다.
2. 코드 조각을 원래 위치에서 잘라내어 목표 위치에 붙여 넣는다.



### 8.7 반복문 쪼개기

반복문 내에서 두가지 일을 하고 있다면 각각의 반복문으로 분리 해두는게 좋다. 하지만 반복문을 두번 실행하므로 꺼려하는 프로그래머도 많다 하지만 리팩터링과 최적화는 구분해야한다. 최적화는 코드를 정리한 이후 수행하자.

1. 반복문을 복제해 두 개로 만든다
2. 반복문이 중복되어 생기는 부수효과를 파악해 제거한다.
3. 각 반복문을 함수로 추출할지 고민해본다.



### 8.8 반복문을 파이프라인으로 바꾸기

반복문을 파이프라인으로 표현하면 이해하기 훨씬 쉬워진다. 객체가 파이프라인을 따라흐르며 어떻게 처리되는지를 읽을 수 있기 때문이다.

1. 반복문에서 사용하는 컬렉션을 가리키는 변수를 하나 만든다
2. 반복문의 첫 줄부터 시작해서 각각의 단위 행위를 적절한 컬렉션 파이프라인 연산으로 대체한다. 이때 컬렉션 파이프라인 연산은 1에서 만든 반복문 컬렉션 변수에서 시작하여 이전 연산의 결과를 기초로 연쇄적으로 수행된다.

3. 반복문의 모든 동작을 대체했다면 반복문 자체를 지운다.





